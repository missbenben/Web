<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
	</head>
	<body>
		
		<script type="text/javascript">
			//冒泡排序
			/*
			 
			 * 解析：1.比较相邻的两个元素，如果前一个比后一个大，则交换位置。

　　　			     2.第一轮的时候最后一个元素应该是最大的一个。

　　　				 3.按照步骤一的方法进行相邻两个元素的比较，这个时候由于最后一个元素已经是最大的了，所以最后一个元素不用比较。
			 * */
			function sort(elements){
				for(var i = 0; i<elements.length - 1;i++){
					for(var j = 0; j<elements.length - 1; j++){
						if(elements[j] > elements[j +1]){
							var swap = elements[j]
							elements[j] = elements[j+1]
							elements[j+1] = swap
						}
					}
				}
			}
			//快速排序
			/*
			 
			 * 解析：快速排序是对冒泡排序的一种改进，第一趟排序时将数据分成两部分，一部分比另一部分的所有数据都要小。然后递归调用，在两边都实行快速排序。
			 * */
			function quickSort(elements){
				if(elements.length <= 1){
					return elements
				}
				var pivotIndex = Math.floor(elements.length/2)
				var pivot = elements.splice(pivotIndex,1)[0]
				var left = []
				var right = []
				
				for(var i = 0; i< elements.length; i++){
					if(elements[i] < pivot){
						left.push(elements[i])
					}else{
						right.push(elements[i])
					}
				}
				
				return quickSort(left).concat([pivot],quickSort(right))
			}
			
			//插入排序
			/*
			 
			 *  （1） 从第一个元素开始，该元素可以认为已经被排序

				 （2） 取出下一个元素，在已经排序的元素序列中从后向前扫描
				
				 （3） 如果该元素（已排序）大于新元素，将该元素移到下一位置
				
				 （4） 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置
				
				 （5）将新元素插入到下一位置中
				
				 （6） 重复步骤2
			 * */
			
			function sort(elements){
				//假设第0个元素是一个有序数列，第1个以后的是无序排序，
				//所以从第1个元素开始将无序数列的元素插入到有序数列中
				for(var i = 1;i<elements.length;i++){
					//升序
					if(elements[i] < elements[i-1]){
						//取出无序数列中的第i个作为被插入元素
						var guard = elements[i]
						//记住有序数列的最后一个位置，并且将有序数列位置扩大一个
						var j = i -1;
						elements[i] = elements[j]
						//比大小，找到被插入元素的所在位置
						while(j>= 0 && guard <elements[j]){
							elements[j + 1] = elements[j]
							j--
						}
						elements[j + 1] = guard //插入
					}
				}
			}
			
			//二分查找
			/*
			 
			 * 解析：二分查找，也为折半查找。首先要找到一个中间值，通过与中间值比较，大的放又，小的放在左边。再在两边中寻找中间值，持续以上操作，直到找到所在位置为止。
			 * */
			//1.递归方法
			function binarySearch(data,dest,start,end){
				var end = end || data.length -1,
				start = start || 0,
				m = Math.floor((start + end)/2);
				
				if(data[m] == dest){
					return m
				}
				
				if(dest <data[m]){
					return binarySearch(data,dest,0,m-1)
				}else{
					retirm binarySearch(data,dest,m+1,end)
				}
				return false
			}
			//2.非递归
			function binary Search(data,dest){
				var h = data.length - 1,
					l = 0;
				while(l <= h){
					var m = Math.floor((h + 1) /2)
					if(data[m] == dest){
						return m
					}
					if(dest >data[m]){
						l = m +1
					}else{
						h = m -1
					}
				}
				return false
			}
			//排序选择
			/*
			 
			 * 解析:首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。
						 以此类推，直到所有元素均排序完毕。
			 * * */
			function selectionSort(arr){
				var len = arr.length
				var minIndex,temp;
				console.time('选择排序耗时')
				for(var i = 0;i<len - 1; i++){
					minIndex = i;
					for(var j = i+1;j<len;j++){
						if(arr[j] <arr[minIndex]){//寻找最小数
							minIndex = j //将最小数的索引保存
						}
					}
					temp = arr[i]
					arr[i] = arr[minIndex]
					arr[minIndex] = temp
				}
				console.timeEnd('选择排序耗时')
				return arr
			}
			
		</script>
	</body>
</html>
